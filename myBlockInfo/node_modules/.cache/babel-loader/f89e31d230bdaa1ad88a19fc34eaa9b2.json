{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst l = (0, _util.logger)('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = (0, _util.u8aToHex)(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type, params = [], isPedantic) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/types/create/createType.js"],"names":["Object","defineProperty","exports","value","createTypeUnsafe","createType","_util","require","_createClass","l","logger","u8aHasValue","some","v","checkInstance","created","rawType","toRawType","inHex","u8aToHex","crHex","toHex","isEqual","reverse","toU8a","warn","initType","registry","Type","params","isPedantic","isU8a","type","createClass","error","Error","message"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst l = (0, _util.logger)('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = (0, _util.u8aToHex)(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type, params = [], isPedantic) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"script"}