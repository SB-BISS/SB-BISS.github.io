{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nexports.mnemonicToEntropy = mnemonicToEntropy;\nexports.entropyToMnemonic = entropyToMnemonic;\nexports.generateMnemonic = generateMnemonic;\nexports.validateMnemonic = validateMnemonic;\n\nvar _createHash = _interopRequireDefault(require(\"create-hash\"));\n\nvar _pbkdf = require(\"pbkdf2\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _asU8a = _interopRequireDefault(require(\"../random/asU8a\"));\n\nvar _bip39En = _interopRequireDefault(require(\"./bip39-en\")); // Copyright 2017-2020 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from the bitcoinjs/bip39 source\n// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts\n// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>\n// ISC Licence\n//\n// Change made in this version -\n//   - Adjust formatting (just eslint differences)\n//   - Only English wordlist (this aligns with the wasm-crypto implementation)\n//   - Use util-crypto randomAsU8a (instead of randombytes)\n//   - Remove setting of wordlost passing of wordlist in functions\n//   - Remove mnemonicToSeed (we only use the sync variant)\n\n\nvar INVALID_MNEMONIC = 'Invalid mnemonic';\nvar INVALID_ENTROPY = 'Invalid entropy';\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(function (x) {\n    return x.toString(2).padStart(8, '0');\n  }).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  var ENT = entropyBuffer.length * 8;\n  var CS = ENT / 32;\n  var hash = (0, _createHash.default)('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  var mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n  var saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n  return (0, _pbkdf.pbkdf2Sync)(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nfunction mnemonicToEntropy(mnemonic) {\n  var _entropyBits$match;\n\n  var words = normalize(mnemonic).split(' ');\n  (0, _util.assert)(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  var bits = words.map(function (word) {\n    var index = _bip39En.default.indexOf(word);\n\n    (0, _util.assert)(index !== -1, INVALID_MNEMONIC);\n    return index.toString(2).padStart(11, '0');\n  }).join(''); // split the binary string into ENT/CS\n\n  var dividerIndex = Math.floor(bits.length / 33) * 32;\n  var entropyBits = bits.slice(0, dividerIndex);\n  var checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  var entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);\n  (0, _util.assert)(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);\n  var entropy = (0, _util.u8aToU8a)(entropyBytes);\n  var newChecksum = deriveChecksumBits(entropy);\n  (0, _util.assert)(newChecksum === checksumBits, INVALID_CHECKSUM);\n  return entropy;\n}\n\nfunction entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  (0, _util.assert)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);\n  var entropyBits = bytesToBinary(Array.from(entropy));\n  var checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n  return (entropyBits + checksumBits).match(/(.{1,11})/g).map(function (binary) {\n    return _bip39En.default[binaryToByte(binary)];\n  }).join(' ');\n}\n\nfunction generateMnemonic(strength) {\n  strength = strength || 128;\n  (0, _util.assert)(strength % 32 === 0, INVALID_ENTROPY);\n  return entropyToMnemonic((0, _asU8a.default)(strength / 8));\n}\n\nfunction validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/api-derive/node_modules/@polkadot/util-crypto/mnemonic/bip39.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","mnemonicToSeedSync","mnemonicToEntropy","entropyToMnemonic","generateMnemonic","validateMnemonic","_createHash","_pbkdf","_util","_asU8a","_bip39En","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","normalize","str","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","padStart","join","deriveChecksumBits","entropyBuffer","ENT","length","CS","hash","default","update","digest","Array","from","slice","salt","password","mnemonic","mnemonicBuffer","Buffer","saltBuffer","pbkdf2Sync","_entropyBits$match","words","split","assert","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","u8aToU8a","newChecksum","binary","strength","e"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nexports.mnemonicToEntropy = mnemonicToEntropy;\nexports.entropyToMnemonic = entropyToMnemonic;\nexports.generateMnemonic = generateMnemonic;\nexports.validateMnemonic = validateMnemonic;\n\nvar _createHash = _interopRequireDefault(require(\"create-hash\"));\n\nvar _pbkdf = require(\"pbkdf2\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _asU8a = _interopRequireDefault(require(\"../random/asU8a\"));\n\nvar _bip39En = _interopRequireDefault(require(\"./bip39-en\"));\n\n// Copyright 2017-2020 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Adapted from the bitcoinjs/bip39 source\n// https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/index.ts\n// Copyright (c) 2014, Wei Lu <luwei.here@gmail.com> and Daniel Cousens <email@dcousens.com>\n// ISC Licence\n//\n// Change made in this version -\n//   - Adjust formatting (just eslint differences)\n//   - Only English wordlist (this aligns with the wasm-crypto implementation)\n//   - Use util-crypto randomAsU8a (instead of randombytes)\n//   - Remove setting of wordlost passing of wordlist in functions\n//   - Remove mnemonicToSeed (we only use the sync variant)\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, '0')).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = (0, _createHash.default)('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n  const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n  return (0, _pbkdf.pbkdf2Sync)(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nfunction mnemonicToEntropy(mnemonic) {\n  var _entropyBits$match;\n\n  const words = normalize(mnemonic).split(' ');\n  (0, _util.assert)(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  const bits = words.map(word => {\n    const index = _bip39En.default.indexOf(word);\n\n    (0, _util.assert)(index !== -1, INVALID_MNEMONIC);\n    return index.toString(2).padStart(11, '0');\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);\n  (0, _util.assert)(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);\n  const entropy = (0, _util.u8aToU8a)(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  (0, _util.assert)(newChecksum === checksumBits, INVALID_CHECKSUM);\n  return entropy;\n}\n\nfunction entropyToMnemonic(entropy) {\n  // 128 <= ENT <= 256\n  (0, _util.assert)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n  return (entropyBits + checksumBits).match(/(.{1,11})/g).map(binary => _bip39En.default[binaryToByte(binary)]).join(' ');\n}\n\nfunction generateMnemonic(strength) {\n  strength = strength || 128;\n  (0, _util.assert)(strength % 32 === 0, INVALID_ENTROPY);\n  return entropyToMnemonic((0, _asU8a.default)(strength / 8));\n}\n\nfunction validateMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}"]},"metadata":{},"sourceType":"script"}