{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MortalEra = exports.ImmortalEra = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Enum = _interopRequireDefault(require(\"../codec/Enum\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _Raw = _interopRequireDefault(require(\"../codec/Raw\"));\n\nvar _U = _interopRequireDefault(require(\"../primitive/U64\"));\n\nvar _constants = require(\"./constants\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nclass ImmortalEra extends _Raw.default {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, _constants.IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\n\nexports.ImmortalEra = ImmortalEra;\n\nclass MortalEra extends _Tuple.default {\n  constructor(registry, value) {\n    super(registry, {\n      period: _U.default,\n      phase: _U.default\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if (!value) {\n      return [new _U.default(registry), new _U.default(registry)];\n    } else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value) || Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, (0, _util.u8aToU8a)(value));\n    } else if ((0, _util.isObject)(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new _U.default(registry, calPeriod), new _U.default(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new _U.default(registry), new _U.default(registry)];\n    }\n\n    const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();\n    const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new _U.default(registry, period), new _U.default(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: (0, _util.formatNumber)(this.period),\n      phase: (0, _util.formatNumber)(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\n\nexports.MortalEra = MortalEra;\n\nclass ExtrinsicEra extends _Enum.default {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, ExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof ExtrinsicEra) {\n      return ExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if ((0, _util.isHex)(value)) {\n      return ExtrinsicEra._decodeExtrinsicEra((0, _util.hexToU8a)(value));\n    } else if (!value || (0, _util.isU8a)(value)) {\n      return !(value === null || value === void 0 ? void 0 : value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if ((0, _util.isObject)(value)) {\n      // this is to de-serialize from JSON\n      return value.MortalEra ? {\n        MortalEra: value.MortalEra\n      } : value.ImmortalEra ? {\n        ImmortalEra: value.ImmortalEra\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    (0, _util.assert)(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    (0, _util.assert)(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}\n\nexports.default = ExtrinsicEra;","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","MortalEra","ImmortalEra","_util","_Enum","_Tuple","_Raw","_U","_constants","getTrailingZeros","period","binary","toString","index","length","constructor","registry","IMMORTAL_ERA","phase","_decodeMortalEra","isU8a","isHex","Array","isArray","_decodeMortalU8a","u8aToU8a","isObject","_decodeMortalObject","Error","current","calPeriod","Math","pow","ceil","log2","min","max","quantizeFactor","quantizedPhase","first","u8aToBn","subarray","toNumber","second","encoded","assert","encodedLength","toHuman","formatNumber","toJSON","toHex","toU8a","isBare","trailingZeros","Uint8Array","birth","floor","bnToBn","death","ExtrinsicEra","_decodeExtrinsicEra","hexToU8a","isImmortalEra","asImmortalEra","asMortalEra","type","isMortalEra"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MortalEra = exports.ImmortalEra = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Enum = _interopRequireDefault(require(\"../codec/Enum\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _Raw = _interopRequireDefault(require(\"../codec/Raw\"));\n\nvar _U = _interopRequireDefault(require(\"../primitive/U64\"));\n\nvar _constants = require(\"./constants\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nclass ImmortalEra extends _Raw.default {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, _constants.IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\n\nexports.ImmortalEra = ImmortalEra;\n\nclass MortalEra extends _Tuple.default {\n  constructor(registry, value) {\n    super(registry, {\n      period: _U.default,\n      phase: _U.default\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if (!value) {\n      return [new _U.default(registry), new _U.default(registry)];\n    } else if ((0, _util.isU8a)(value) || (0, _util.isHex)(value) || Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, (0, _util.u8aToU8a)(value));\n    } else if ((0, _util.isObject)(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new _U.default(registry, calPeriod), new _U.default(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new _U.default(registry), new _U.default(registry)];\n    }\n\n    const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();\n    const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new _U.default(registry, period), new _U.default(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: (0, _util.formatNumber)(this.period),\n      phase: (0, _util.formatNumber)(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\n\nexports.MortalEra = MortalEra;\n\nclass ExtrinsicEra extends _Enum.default {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, ExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof ExtrinsicEra) {\n      return ExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if ((0, _util.isHex)(value)) {\n      return ExtrinsicEra._decodeExtrinsicEra((0, _util.hexToU8a)(value));\n    } else if (!value || (0, _util.isU8a)(value)) {\n      return !(value === null || value === void 0 ? void 0 : value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if ((0, _util.isObject)(value)) {\n      // this is to de-serialize from JSON\n      return value.MortalEra ? {\n        MortalEra: value.MortalEra\n      } : value.ImmortalEra ? {\n        ImmortalEra: value.ImmortalEra\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    (0, _util.assert)(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    (0, _util.assert)(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}\n\nexports.default = ExtrinsicEra;"]},"metadata":{},"sourceType":"script"}