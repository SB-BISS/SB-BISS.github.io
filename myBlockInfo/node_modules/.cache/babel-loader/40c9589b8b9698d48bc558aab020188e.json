{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _construct = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct\");\n\nvar _toConsumableArray = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nvar l = (0, _util.logger)('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(function (v) {\n    return !!v;\n  });\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  var rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  var inHex = (0, _util.u8aToHex)(value);\n  var crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  var isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(\"\".concat(rawType, \":: Input doesn't match output, received \").concat((0, _util.u8aToHex)(value), \", created \").concat(crHex));\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var isPedantic = arguments.length > 3 ? arguments[3] : undefined;\n\n  var created = _construct(Type, [registry].concat(_toConsumableArray(params))); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n  var _params = _slicedToArray(params, 1),\n      value = _params[0];\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var isPedantic = arguments.length > 3 ? arguments[3] : undefined;\n\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(\"createType(\".concat(type, \"):: \").concat(error.message));\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type) {\n  for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    params[_key - 2] = arguments[_key];\n  }\n\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/types/create/createType.js"],"names":["Object","defineProperty","exports","value","createTypeUnsafe","createType","_util","require","_createClass","l","logger","u8aHasValue","some","v","checkInstance","created","rawType","toRawType","inHex","u8aToHex","crHex","toHex","isEqual","reverse","toU8a","warn","initType","registry","Type","params","isPedantic","isU8a","type","createClass","error","Error","message"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst l = (0, _util.logger)('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = (0, _util.u8aToHex)(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type, params = [], isPedantic) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"script"}