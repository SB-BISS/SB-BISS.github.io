{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new _codec.Raw(registry, type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher));\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/metadata/decorate/storage/createFunction.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","createFunction","_defineProperty2","_codec","_create","_util","_utilCrypto","_getHasher","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","EMPTY_U8A","Uint8Array","NULL_HASHER","getHashers","meta","type","isDoubleMap","asDoubleMap","hasher","key2Hasher","isMap","asMap","createPrefixedKey","method","prefix","u8aConcat","xxhashAsU8a","createKeyDoubleMap","registry","itemFn","args","hasher1","hasher2","name","assert","Array","isArray","isUndefined","isNull","toString","key1","key2","map","val1","createTypeUnsafe","toU8a","val2","Compact","addLengthPrefix","createKey","arg","param","expandWithMeta","section","_storageFn","storageFn","stringLowerFirst","toJSON","storage","extendHeadMeta","documentation","iterFn","outputType","createType","fallback","toHex","modifier","prefixKey","extendPrefixedMap","iterKey","Raw","options","skipHashing","keyPrefix","compactStripLength"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new _codec.Raw(registry, type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher));\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"script"}