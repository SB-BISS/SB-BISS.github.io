{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\n// Copyright 2019-2020 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nvar _require = require('@polkadot/util'),\n    assert = _require.assert,\n    stringToU8a = _require.stringToU8a,\n    u8aToString = _require.u8aToString;\n\nvar wasm;\nvar cachegetInt32 = null;\nvar cachegetUint8 = null;\n\nfunction initWasm(_x, _x2, _x3) {\n  return _initWasm.apply(this, arguments);\n}\n\nfunction _initWasm() {\n  _initWasm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(wasmBytes, asmFn, wbg) {\n    var source;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');\n            _context.next = 4;\n            return WebAssembly.instantiate(wasmBytes, {\n              wbg: wbg\n            });\n\n          case 4:\n            source = _context.sent;\n            wasm = source.instance.exports;\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n\n            // if we have a valid supplied asm.js, return that\n            if (asmFn) {\n              wasm = asmFn(wbg);\n            } else {\n              console.error('ERROR: Unable to initialize @polkadot/wasm-crypto');\n              console.error(_context.t0);\n              wasm = null;\n            }\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8]]);\n  }));\n  return _initWasm.apply(this, arguments);\n}\n\nfunction withWasm(fn) {\n  return function () {\n    assert(wasm, '@polkadot/wasm-crypto has not been initialized. Ensure that you wait for the initialization Promise with waitReady() (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');\n\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    return fn.apply(void 0, [wasm].concat(params));\n  };\n}\n\nfunction getWasm() {\n  return wasm;\n}\n\nfunction getInt32() {\n  if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {\n    cachegetInt32 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32;\n}\n\nfunction getUint8() {\n  if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {\n    cachegetUint8 = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8;\n}\n\nfunction getU8a(ptr, len) {\n  return getUint8().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction getString(ptr, len) {\n  return u8aToString(getU8a(ptr, len));\n}\n\nfunction allocU8a(arg) {\n  var ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8().set(arg, ptr / 1);\n  return [ptr, arg.length];\n}\n\nfunction allocString(arg) {\n  return allocU8a(stringToU8a(arg));\n}\n\nfunction resultU8a() {\n  var r0 = getInt32()[8 / 4 + 0];\n  var r1 = getInt32()[8 / 4 + 1];\n  var ret = getU8a(r0, r1).slice();\n\n  wasm.__wbindgen_free(r0, r1 * 1);\n\n  return ret;\n}\n\nfunction resultString() {\n  return u8aToString(resultU8a());\n}\n\nmodule.exports = {\n  allocString: allocString,\n  allocU8a: allocU8a,\n  getInt32: getInt32,\n  getString: getString,\n  getU8a: getU8a,\n  getWasm: getWasm,\n  initWasm: initWasm,\n  resultString: resultString,\n  resultU8a: resultU8a,\n  withWasm: withWasm\n};","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/types/node_modules/@polkadot/wasm-crypto/bridge.js"],"names":["require","assert","stringToU8a","u8aToString","wasm","cachegetInt32","cachegetUint8","initWasm","wasmBytes","asmFn","wbg","WebAssembly","length","instantiate","source","instance","exports","console","error","withWasm","fn","params","getWasm","getInt32","buffer","memory","Int32Array","getUint8","Uint8Array","getU8a","ptr","len","subarray","getString","allocU8a","arg","__wbindgen_malloc","set","allocString","resultU8a","r0","r1","ret","slice","__wbindgen_free","resultString","module"],"mappings":"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","sourcesContent":["// Copyright 2019-2020 @polkadot/wasm-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nconst { assert, stringToU8a, u8aToString } = require('@polkadot/util');\n\nlet wasm;\nlet cachegetInt32 = null;\nlet cachegetUint8 = null;\n\nasync function initWasm (wasmBytes, asmFn, wbg) {\n  try {\n    assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');\n\n    const source = await WebAssembly.instantiate(wasmBytes, { wbg });\n\n    wasm = source.instance.exports;\n  } catch (error) {\n    // if we have a valid supplied asm.js, return that\n    if (asmFn) {\n      wasm = asmFn(wbg);\n    } else {\n      console.error('ERROR: Unable to initialize @polkadot/wasm-crypto');\n      console.error(error);\n\n      wasm = null;\n    }\n  }\n}\n\nfunction withWasm (fn) {\n  return (...params) => {\n    assert(wasm, '@polkadot/wasm-crypto has not been initialized. Ensure that you wait for the initialization Promise with waitReady() (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');\n\n    return fn(wasm, ...params);\n  };\n}\n\nfunction getWasm () {\n  return wasm;\n}\n\nfunction getInt32 () {\n  if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {\n    cachegetInt32 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32;\n}\n\nfunction getUint8 () {\n  if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {\n    cachegetUint8 = new Uint8Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint8;\n}\n\nfunction getU8a (ptr, len) {\n  return getUint8().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction getString (ptr, len) {\n  return u8aToString(getU8a(ptr, len));\n}\n\nfunction allocU8a (arg) {\n  const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n\n  getUint8().set(arg, ptr / 1);\n\n  return [ptr, arg.length];\n}\n\nfunction allocString (arg) {\n  return allocU8a(stringToU8a(arg));\n}\n\nfunction resultU8a () {\n  const r0 = getInt32()[8 / 4 + 0];\n  const r1 = getInt32()[8 / 4 + 1];\n  const ret = getU8a(r0, r1).slice();\n\n  wasm.__wbindgen_free(r0, r1 * 1);\n\n  return ret;\n}\n\nfunction resultString () {\n  return u8aToString(resultU8a());\n}\n\nmodule.exports = {\n  allocString,\n  allocU8a,\n  getInt32,\n  getString,\n  getU8a,\n  getWasm,\n  initWasm,\n  resultString,\n  resultU8a,\n  withWasm\n};\n"]},"metadata":{},"sourceType":"script"}