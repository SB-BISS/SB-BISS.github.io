{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar EMPTY_U8A = new Uint8Array([]);\n\nvar NULL_HASHER = function NULL_HASHER(value) {\n  return value;\n}; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers(_ref) {\n  var type = _ref.meta.type;\n\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey(_ref2) {\n  var method = _ref2.method,\n      prefix = _ref2.prefix;\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, _ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      hasher1 = _ref4[0],\n      hasher2 = _ref4[1];\n\n  var _itemFn$meta = itemFn.meta,\n      name = _itemFn$meta.name,\n      type = _itemFn$meta.type; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), \"\".concat((name || 'unknown').toString(), \" is a DoubleMap and requires two arguments\")); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n\n  var _args = _slicedToArray(args, 2),\n      key1 = _args[0],\n      key2 = _args[1];\n\n  var map = type.asDoubleMap;\n  var val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  var val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  var _itemFn$meta2 = itemFn.meta,\n      name = _itemFn$meta2.name,\n      type = _itemFn$meta2.type;\n  var param = EMPTY_U8A;\n\n  if (type.isMap) {\n    var map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), \"\".concat(name.toString(), \" is a Map and requires one argument\"));\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta(_ref5, _storageFn) {\n  var meta = _ref5.meta,\n      method = _ref5.method,\n      prefix = _ref5.prefix,\n      section = _ref5.section;\n  var storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = function () {\n    return _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n      storage: {\n        method: method,\n        prefix: prefix,\n        section: section\n      }\n    });\n  };\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, _ref6, _ref7, iterFn) {\n  var _ref6$meta = _ref6.meta,\n      documentation = _ref6$meta.documentation,\n      name = _ref6$meta.name,\n      type = _ref6$meta.type,\n      section = _ref6.section;\n  var method = _ref7.method;\n  var outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation: documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name: name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  var prefixKey = registry.createType('StorageKey', iterFn, {\n    method: method,\n    section: section\n  });\n  return function (arg) {\n    return !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n      method: method,\n      section: section\n    }) : prefixKey;\n  };\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  var type = itemFn.meta.type;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, function (arg) {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new _codec.Raw(registry, type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  var type = itemFn.meta.type;\n\n  var _getHashers = getHashers(itemFn),\n      _getHashers2 = _slicedToArray(_getHashers, 2),\n      hasher = _getHashers2[0],\n      key2Hasher = _getHashers2[1]; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n\n  var storageFn = expandWithMeta(itemFn, function (arg) {\n    return type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher);\n  });\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = function (arg) {\n    return storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n  };\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/metadata/decorate/storage/createFunction.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","createFunction","_defineProperty2","_codec","_create","_util","_utilCrypto","_getHasher","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","EMPTY_U8A","Uint8Array","NULL_HASHER","getHashers","type","meta","isDoubleMap","asDoubleMap","hasher","key2Hasher","isMap","asMap","createPrefixedKey","method","prefix","u8aConcat","xxhashAsU8a","createKeyDoubleMap","registry","itemFn","args","hasher1","hasher2","name","assert","Array","isArray","isUndefined","isNull","toString","key1","key2","map","val1","createTypeUnsafe","toU8a","val2","Compact","addLengthPrefix","createKey","arg","param","expandWithMeta","_storageFn","section","storageFn","stringLowerFirst","toJSON","storage","extendHeadMeta","iterFn","documentation","outputType","createType","fallback","toHex","modifier","prefixKey","extendPrefixedMap","iterKey","Raw","options","skipHashing","keyPrefix","compactStripLength"],"mappings":"AAAA;;;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,cAAlB;;AAEA,IAAIC,gBAAgB,GAAGR,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIQ,MAAM,GAAGR,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIS,OAAO,GAAGT,OAAO,CAAC,wBAAD,CAArB;;AAEA,IAAIU,KAAK,GAAGV,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAIW,WAAW,GAAGX,OAAO,CAAC,uBAAD,CAAzB;;AAEA,IAAIY,UAAU,GAAGb,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,SAASa,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGf,MAAM,CAACe,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIb,MAAM,CAACgB,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGjB,MAAM,CAACgB,qBAAP,CAA6BH,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBG,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOnB,MAAM,CAACoB,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GN,IAAAA,IAAI,CAACO,IAAL,CAAUC,KAAV,CAAgBR,IAAhB,EAAsBE,OAAtB;AAAiC;;AAAC,SAAOF,IAAP;AAAc;;AAErV,SAASS,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEd,MAAAA,OAAO,CAACZ,MAAM,CAAC6B,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAE,SAAC,GAAGzB,gBAAgB,CAACF,OAArB,EAA8BqB,MAA9B,EAAsCM,GAAtC,EAA2CF,MAAM,CAACE,GAAD,CAAjD;AAA0D,OAAjH;AAAqH,KAAlI,MAAwI,IAAI/B,MAAM,CAACgC,yBAAX,EAAsC;AAAEhC,MAAAA,MAAM,CAACiC,gBAAP,CAAwBR,MAAxB,EAAgCzB,MAAM,CAACgC,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAEjB,MAAAA,OAAO,CAACZ,MAAM,CAAC6B,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAE/B,QAAAA,MAAM,CAACC,cAAP,CAAsBwB,MAAtB,EAA8BM,GAA9B,EAAmC/B,MAAM,CAACoB,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEpiB,IAAMS,SAAS,GAAG,IAAIC,UAAJ,CAAe,EAAf,CAAlB;;AAEA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAjC,KAAK;AAAA,SAAIA,KAAJ;AAAA,CAAzB,C,CAAoC;;AAEpC;;;AAGA,SAASkC,UAAT,OAIG;AAAA,MAFCC,IAED,QAHDC,IAGC,CAFCD,IAED;;AACD,MAAIA,IAAI,CAACE,WAAT,EAAsB;AACpB,WAAO,CAAC,CAAC,GAAG7B,UAAU,CAACP,OAAf,EAAwBkC,IAAI,CAACG,WAAL,CAAiBC,MAAzC,CAAD,EAAmD,CAAC,GAAG/B,UAAU,CAACP,OAAf,EAAwBkC,IAAI,CAACG,WAAL,CAAiBE,UAAzC,CAAnD,CAAP;AACD,GAFD,MAEO,IAAIL,IAAI,CAACM,KAAT,EAAgB;AACrB,WAAO,CAAC,CAAC,GAAGjC,UAAU,CAACP,OAAf,EAAwBkC,IAAI,CAACO,KAAL,CAAWH,MAAnC,CAAD,CAAP;AACD,GALA,CAKC;;;AAGF,SAAO,CAAC,CAAC,GAAG/B,UAAU,CAACP,OAAf,GAAD,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAAS0C,iBAAT,QAGG;AAAA,MAFDC,MAEC,SAFDA,MAEC;AAAA,MADDC,MACC,SADDA,MACC;AACD,SAAO,CAAC,GAAGvC,KAAK,CAACwC,SAAV,EAAqB,CAAC,GAAGvC,WAAW,CAACwC,WAAhB,EAA6BF,MAA7B,EAAqC,GAArC,CAArB,EAAgE,CAAC,GAAGtC,WAAW,CAACwC,WAAhB,EAA6BH,MAA7B,EAAqC,GAArC,CAAhE,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASI,kBAAT,CAA4BC,QAA5B,EAAsCC,MAAtC,EAA8CC,IAA9C,SAAwE;AAAA;AAAA,MAAnBC,OAAmB;AAAA,MAAVC,OAAU;;AAAA,qBAMlEH,MANkE,CAEpEd,IAFoE;AAAA,MAGlEkB,IAHkE,gBAGlEA,IAHkE;AAAA,MAIlEnB,IAJkE,gBAIlEA,IAJkE,EAM1D;;AAEZ,GAAC,GAAG7B,KAAK,CAACiD,MAAV,EAAkBC,KAAK,CAACC,OAAN,CAAcN,IAAd,KAAuB,CAAC,CAAC,GAAG7C,KAAK,CAACoD,WAAV,EAAuBP,IAAI,CAAC,CAAD,CAA3B,CAAxB,IAA2D,CAAC,CAAC,GAAG7C,KAAK,CAACqD,MAAV,EAAkBR,IAAI,CAAC,CAAD,CAAtB,CAA5D,IAA0F,CAAC,CAAC,GAAG7C,KAAK,CAACoD,WAAV,EAAuBP,IAAI,CAAC,CAAD,CAA3B,CAA3F,IAA8H,CAAC,CAAC,GAAG7C,KAAK,CAACqD,MAAV,EAAkBR,IAAI,CAAC,CAAD,CAAtB,CAAjJ,YAAgL,CAACG,IAAI,IAAI,SAAT,EAAoBM,QAApB,EAAhL,iDARsE,CAQuL;;AAE7P,GAAC,GAAGtD,KAAK,CAACiD,MAAV,EAAkB,CAAC,CAAC,GAAGjD,KAAK,CAACoD,WAAV,EAAuBL,OAAvB,CAAnB,EAAoD,sDAApD;;AAVsE,6BAWjDF,IAXiD;AAAA,MAW/DU,IAX+D;AAAA,MAWzDC,IAXyD;;AAYtE,MAAMC,GAAG,GAAG5B,IAAI,CAACG,WAAjB;AACA,MAAM0B,IAAI,GAAG,CAAC,GAAG3D,OAAO,CAAC4D,gBAAZ,EAA8BhB,QAA9B,EAAwCc,GAAG,CAACF,IAAJ,CAASD,QAAT,EAAxC,EAA6D,CAACC,IAAD,CAA7D,EAAqEK,KAArE,EAAb;AACA,MAAMC,IAAI,GAAG,CAAC,GAAG9D,OAAO,CAAC4D,gBAAZ,EAA8BhB,QAA9B,EAAwCc,GAAG,CAACD,IAAJ,CAASF,QAAT,EAAxC,EAA6D,CAACE,IAAD,CAA7D,EAAqEI,KAArE,EAAb,CAdsE,CAcqB;;AAE3F,SAAO9D,MAAM,CAACgE,OAAP,CAAeC,eAAf,CAA+B,CAAC,GAAG/D,KAAK,CAACwC,SAAV,EAAqBH,iBAAiB,CAACO,MAAD,CAAtC,EAAgDE,OAAO,CAACY,IAAD,CAAvD,EAA+DX,OAAO,CAACc,IAAD,CAAtE,CAA/B,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAASG,SAAT,CAAmBrB,QAAnB,EAA6BC,MAA7B,EAAqCqB,GAArC,EAA0ChC,MAA1C,EAAkD;AAAA,sBAM5CW,MAN4C,CAE9Cd,IAF8C;AAAA,MAG5CkB,IAH4C,iBAG5CA,IAH4C;AAAA,MAI5CnB,IAJ4C,iBAI5CA,IAJ4C;AAOhD,MAAIqC,KAAK,GAAGzC,SAAZ;;AAEA,MAAII,IAAI,CAACM,KAAT,EAAgB;AACd,QAAMsB,GAAG,GAAG5B,IAAI,CAACO,KAAjB;AACA,KAAC,GAAGpC,KAAK,CAACiD,MAAV,EAAkB,CAAC,CAAC,GAAGjD,KAAK,CAACoD,WAAV,EAAuBa,GAAvB,CAAD,IAAgC,CAAC,CAAC,GAAGjE,KAAK,CAACqD,MAAV,EAAkBY,GAAlB,CAAnD,YAA8EjB,IAAI,CAACM,QAAL,EAA9E;AACAY,IAAAA,KAAK,GAAG,CAAC,GAAGnE,OAAO,CAAC4D,gBAAZ,EAA8BhB,QAA9B,EAAwCc,GAAG,CAACnC,GAAJ,CAAQgC,QAAR,EAAxC,EAA4D,CAACW,GAAD,CAA5D,EAAmEL,KAAnE,EAAR;AACD,GAb+C,CAa9C;;;AAGF,SAAO9D,MAAM,CAACgE,OAAP,CAAeC,eAAf,CAA+B,CAAC,GAAG/D,KAAK,CAACwC,SAAV,EAAqBH,iBAAiB,CAACO,MAAD,CAAtC,EAAgDsB,KAAK,CAAC/C,MAAN,GAAec,MAAM,CAACiC,KAAD,CAArB,GAA+BzC,SAA/E,CAA/B,CAAP;AACD,C,CAAC;;AAEF;;;AAGA,SAAS0C,cAAT,QAKGC,UALH,EAKe;AAAA,MAJbtC,IAIa,SAJbA,IAIa;AAAA,MAHbQ,MAGa,SAHbA,MAGa;AAAA,MAFbC,MAEa,SAFbA,MAEa;AAAA,MADb8B,OACa,SADbA,OACa;AACb,MAAMC,SAAS,GAAGF,UAAlB;AACAE,EAAAA,SAAS,CAACxC,IAAV,GAAiBA,IAAjB;AACAwC,EAAAA,SAAS,CAAChC,MAAV,GAAmB,CAAC,GAAGtC,KAAK,CAACuE,gBAAV,EAA4BjC,MAA5B,CAAnB;AACAgC,EAAAA,SAAS,CAAC/B,MAAV,GAAmBA,MAAnB;AACA+B,EAAAA,SAAS,CAACD,OAAV,GAAoBA,OAApB,CALa,CAKgB;AAC7B;;AAEAC,EAAAA,SAAS,CAACE,MAAV,GAAmB;AAAA,WAAMzD,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKe,IAAI,CAAC0C,MAAL,EAAL,CAAd,EAAmC,EAAnC,EAAuC;AAC3EC,MAAAA,OAAO,EAAE;AACPnC,QAAAA,MAAM,EAANA,MADO;AAEPC,QAAAA,MAAM,EAANA,MAFO;AAGP8B,QAAAA,OAAO,EAAPA;AAHO;AADkE,KAAvC,CAAnB;AAAA,GAAnB;;AAQA,SAAOC,SAAP;AACD;AACD;;;AAGA,SAASI,cAAT,CAAwB/B,QAAxB,gBASGgC,MATH,EASW;AAAA,yBART7C,IAQS;AAAA,MAPP8C,aAOO,cAPPA,aAOO;AAAA,MANP5B,IAMO,cANPA,IAMO;AAAA,MALPnB,IAKO,cALPA,IAKO;AAAA,MAHTwC,OAGS,SAHTA,OAGS;AAAA,MADT/B,MACS,SADTA,MACS;AACT,MAAMuC,UAAU,GAAGhD,IAAI,CAACM,KAAL,GAAaN,IAAI,CAACO,KAAL,CAAWd,GAAX,CAAegC,QAAf,EAAb,GAAyCzB,IAAI,CAACG,WAAL,CAAiBuB,IAAjB,CAAsBD,QAAtB,EAA5D,CADS,CACqF;AAC9F;;AAEAqB,EAAAA,MAAM,CAAC7C,IAAP,GAAca,QAAQ,CAACmC,UAAT,CAAoB,4BAApB,EAAkD;AAC9DF,IAAAA,aAAa,EAAbA,aAD8D;AAE9DG,IAAAA,QAAQ,EAAEpC,QAAQ,CAACmC,UAAT,CAAoB,OAApB,EAA6B,CAAC,GAAG/E,OAAO,CAAC4D,gBAAZ,EAA8BhB,QAA9B,EAAwCkC,UAAxC,EAAoDG,KAApD,EAA7B,CAFoD;AAG9DC,IAAAA,QAAQ,EAAEtC,QAAQ,CAACmC,UAAT,CAAoB,4BAApB,EAAkD,CAAlD,CAHoD;AAI9D;AACA9B,IAAAA,IAAI,EAAJA,IAL8D;AAM9DnB,IAAAA,IAAI,EAAEc,QAAQ,CAACmC,UAAT,CAAoB,wBAApB,EAA8CnC,QAAQ,CAACmC,UAAT,CAAoB,MAApB,EAA4BjD,IAAI,CAACM,KAAL,GAAaN,IAAI,CAACO,KAAL,CAAWd,GAAxB,GAA8BO,IAAI,CAACG,WAAL,CAAiBuB,IAA3E,CAA9C,EAAgI,CAAhI;AANwD,GAAlD,CAAd;AAQA,MAAM2B,SAAS,GAAGvC,QAAQ,CAACmC,UAAT,CAAoB,YAApB,EAAkCH,MAAlC,EAA0C;AAC1DrC,IAAAA,MAAM,EAANA,MAD0D;AAE1D+B,IAAAA,OAAO,EAAPA;AAF0D,GAA1C,CAAlB;AAIA,SAAO,UAAAJ,GAAG;AAAA,WAAI,CAAC,CAAC,GAAGjE,KAAK,CAACoD,WAAV,EAAuBa,GAAvB,CAAD,IAAgC,CAAC,CAAC,GAAGjE,KAAK,CAACqD,MAAV,EAAkBY,GAAlB,CAAjC,GAA0DtB,QAAQ,CAACmC,UAAT,CAAoB,YAApB,EAAkCH,MAAM,CAACV,GAAD,CAAxC,EAA+C;AACrH3B,MAAAA,MAAM,EAANA,MADqH;AAErH+B,MAAAA,OAAO,EAAPA;AAFqH,KAA/C,CAA1D,GAGTa,SAHK;AAAA,GAAV;AAID,C,CAAC;;AAEF;;;AAGA,SAASC,iBAAT,CAA2BxC,QAA3B,EAAqCC,MAArC,EAA6C0B,SAA7C,EAAwD;AAAA,MAGlDzC,IAHkD,GAKlDe,MALkD,CAEpDd,IAFoD,CAGlDD,IAHkD;AAMtDyC,EAAAA,SAAS,CAACc,OAAV,GAAoBV,cAAc,CAAC/B,QAAD,EAAWC,MAAX,EAAmB0B,SAAnB,EAA8B,UAAAL,GAAG,EAAI;AACrE,KAAC,GAAGjE,KAAK,CAACiD,MAAV,EAAkBpB,IAAI,CAACE,WAAL,IAAoB,CAAC,GAAG/B,KAAK,CAACoD,WAAV,EAAuBa,GAAvB,CAAtC,EAAmE,oEAAnE;AACA,WAAO,IAAInE,MAAM,CAACuF,GAAX,CAAe1C,QAAf,EAAyBd,IAAI,CAACE,WAAL,IAAoB,CAAC,CAAC,GAAG/B,KAAK,CAACoD,WAAV,EAAuBa,GAAvB,CAArB,IAAoD,CAAC,CAAC,GAAGjE,KAAK,CAACqD,MAAV,EAAkBY,GAAlB,CAArD,GAA8E,CAAC,GAAGjE,KAAK,CAACwC,SAAV,EAAqBH,iBAAiB,CAACO,MAAD,CAAtC,EAAgD,CAAC,GAAG1C,UAAU,CAACP,OAAf,EAAwBkC,IAAI,CAACG,WAAL,CAAiBC,MAAzC,EAAiDU,QAAQ,CAACmC,UAAT,CAAoBjD,IAAI,CAACG,WAAL,CAAiBuB,IAAjB,CAAsBD,QAAtB,EAApB,EAAsDW,GAAtD,EAA2DL,KAA3D,EAAjD,CAAhD,CAA9E,GAAsPvB,iBAAiB,CAACO,MAAD,CAAhS,CAAP;AACD,GAHiC,CAAlC;AAIA,SAAO0B,SAAP;AACD;AACD;;;AAGA,SAAS1E,cAAT,CAAwB+C,QAAxB,EAAkCC,MAAlC,EAA0C0C,OAA1C,EAAmD;AAAA,MAG7CzD,IAH6C,GAK7Ce,MAL6C,CAE/Cd,IAF+C,CAG7CD,IAH6C;;AAAA,oBAMpBD,UAAU,CAACgB,MAAD,CANU;AAAA;AAAA,MAM1CX,MAN0C;AAAA,MAMlCC,UANkC,oBAMA;AACjD;AACA;AACA;;;AAEA,MAAMoC,SAAS,GAAGH,cAAc,CAACvB,MAAD,EAAS,UAAAqB,GAAG;AAAA,WAAIpC,IAAI,CAACE,WAAL,GAAmBW,kBAAkB,CAACC,QAAD,EAAWC,MAAX,EAAmBqB,GAAnB,EAAwB,CAAChC,MAAD,EAASC,UAAT,CAAxB,CAArC,GAAqF8B,SAAS,CAACrB,QAAD,EAAWC,MAAX,EAAmBqB,GAAnB,EAAwBqB,OAAO,CAACC,WAAR,GAAsB5D,WAAtB,GAAoCM,MAA5D,CAAlG;AAAA,GAAZ,CAAhC;;AAEA,MAAIJ,IAAI,CAACM,KAAL,IAAcN,IAAI,CAACE,WAAvB,EAAoC;AAClCoD,IAAAA,iBAAiB,CAACxC,QAAD,EAAWC,MAAX,EAAmB0B,SAAnB,CAAjB;AACD;;AAEDA,EAAAA,SAAS,CAACkB,SAAV,GAAsB,UAAAvB,GAAG;AAAA,WAAIK,SAAS,CAACc,OAAV,IAAqBd,SAAS,CAACc,OAAV,CAAkBnB,GAAlB,CAArB,IAA+C,CAAC,GAAGjE,KAAK,CAACyF,kBAAV,EAA8BnB,SAAS,EAAvC,EAA2C,CAA3C,CAAnD;AAAA,GAAzB;;AAEA,SAAOA,SAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new _codec.Raw(registry, type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher));\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"script"}