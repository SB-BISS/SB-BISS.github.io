{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"./Compact\"));\n\nvar _utils = require(\"./utils\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nvar MAX_LENGTH = 64 * 1024;\nvar l = (0, _util.logger)('Vec');\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nvar Vec = /*#__PURE__*/function (_AbstractArray$defaul) {\n  _inherits(Vec, _AbstractArray$defaul);\n\n  var _super = _createSuper(Vec);\n\n  function Vec(registry, Type) {\n    var _this;\n\n    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Vec);\n\n    var Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    _this = _super.call.apply(_super, [this, registry].concat(_toConsumableArray(Vec.decodeVec(registry, Clazz, value))));\n    _this._Type = void 0;\n    _this._Type = Clazz;\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(Vec, [{\n    key: \"indexOf\",\n\n    /**\n     * @description Finds the index of the value in the array\n     */\n    value: function indexOf(_other) {\n      // convert type first, this removes overhead from the eq\n      var other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n      for (var i = 0; i < this.length; i++) {\n        if (other.eq(this[i])) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n\n  }, {\n    key: \"toRawType\",\n    value: function toRawType() {\n      return \"Vec<\".concat(this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType(), \">\");\n    }\n  }, {\n    key: \"Type\",\n\n    /**\n     * @description The type for the items\n     */\n    get: function get() {\n      return this._Type.name;\n    }\n  }], [{\n    key: \"decodeVec\",\n    value: function decodeVec(registry, Type, value) {\n      if (Array.isArray(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return value.map(function (entry, index) {\n          try {\n            return entry instanceof Type ? entry : new Type(registry, entry);\n          } catch (error) {\n            l.error(\"Unable to decode on index \".concat(index), error.message);\n            throw error;\n          }\n        });\n      }\n\n      var u8a = (0, _util.u8aToU8a)(value);\n\n      var _Compact$default$deco = _Compact.default.decodeU8a(u8a),\n          _Compact$default$deco2 = _slicedToArray(_Compact$default$deco, 2),\n          offset = _Compact$default$deco2[0],\n          length = _Compact$default$deco2[1];\n\n      (0, _util.assert)(length.lten(MAX_LENGTH), \"Vec length \".concat(length.toString(), \" exceeds \").concat(MAX_LENGTH));\n      return (0, _utils.decodeU8a)(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n    }\n  }, {\n    key: \"with\",\n    value: function _with(Type) {\n      return /*#__PURE__*/function (_Vec) {\n        _inherits(_class, _Vec);\n\n        var _super2 = _createSuper(_class);\n\n        function _class(registry, value) {\n          _classCallCheck(this, _class);\n\n          return _super2.call(this, registry, Type, value);\n        }\n\n        return _class;\n      }(Vec);\n    }\n  }]);\n\n  return Vec;\n}(_AbstractArray.default);\n\nexports.default = Vec;","map":{"version":3,"sources":["/home/tmaltus/Documents/BlockChainProjects/dotNetworkBlockInfo/node_modules/@polkadot/types/codec/Vec.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_util","_Compact","_utils","_AbstractArray","MAX_LENGTH","l","logger","Vec","registry","Type","Clazz","typeToConstructor","decodeVec","_Type","_other","other","i","length","eq","getClassName","toRawType","name","Array","isArray","map","entry","index","error","message","u8a","u8aToU8a","decodeU8a","offset","assert","lten","toString","subarray","toNumber","fill"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"./Compact\"));\n\nvar _utils = require(\"./utils\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst MAX_LENGTH = 64 * 1024;\nconst l = (0, _util.logger)('Vec');\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nclass Vec extends _AbstractArray.default {\n  constructor(registry, Type, value = []) {\n    const Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    super(registry, ...Vec.decodeVec(registry, Clazz, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVec(registry, Type, value) {\n    if (Array.isArray(value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return value.map((entry, index) => {\n        try {\n          return entry instanceof Type ? entry : new Type(registry, entry);\n        } catch (error) {\n          l.error(`Unable to decode on index ${index}`, error.message);\n          throw error;\n        }\n      });\n    }\n\n    const u8a = (0, _util.u8aToU8a)(value);\n\n    const [offset, length] = _Compact.default.decodeU8a(u8a);\n\n    (0, _util.assert)(length.lten(MAX_LENGTH), `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    return (0, _utils.decodeU8a)(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n  }\n\n  static with(Type) {\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return this._Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n\n\n  indexOf(_other) {\n    // convert type first, this removes overhead from the eq\n    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n    for (let i = 0; i < this.length; i++) {\n      if (other.eq(this[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;\n  }\n\n}\n\nexports.default = Vec;"]},"metadata":{},"sourceType":"script"}