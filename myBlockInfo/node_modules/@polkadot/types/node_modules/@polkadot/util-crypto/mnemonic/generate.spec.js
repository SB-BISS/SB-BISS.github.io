"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _generate = _interopRequireDefault(require("./generate"));

var _validate = _interopRequireDefault(require("./validate"));

var _ = require("..");

// Copyright 2017-2020 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
describe('mnemonicGenerate', () => {
  beforeEach(async () => {
    await (0, _.cryptoWaitReady)();
  });
  it('generates a valid mnemonic (default strength)', () => {
    expect((0, _validate.default)((0, _generate.default)())).toEqual(true);
  });
  [false, true].forEach(onlyJs => {
    [12, 15, 18, 21, 24].forEach(num => {
      it(`generates a valid mnemonic (${num} words, onlyJs=${onlyJs.toString()})`, () => {
        const mnemonic = (0, _generate.default)(num, onlyJs);
        const isValid = (0, _validate.default)(mnemonic);
        expect(mnemonic.split(' ')).toHaveLength(num);
        expect(isValid).toEqual(true);
      });
    });
  });
  [true, false].forEach(onlyJs => {
    it(`generates not deterministic (onlyJs=${onlyJs.toString()})`, () => {
      [false, true].forEach(onlyJs => {
        const m1 = (0, _generate.default)(24, onlyJs);
        const m2 = (0, _generate.default)(24, onlyJs);
        expect(m1 === m2).toEqual(false);
        expect((0, _validate.default)(m1)).toEqual(true);
        expect((0, _validate.default)(m2)).toEqual(true);
      });
    });
  });
});